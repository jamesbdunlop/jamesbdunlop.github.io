---
layout: default
title: "Eyelid c++ Node part01"
isPost: true
description: "Creating an eyelid node in Maya"
usage: "N-A"
lastUpdated: "03-04-2018"
category: c++
---
<center><h1>Maya EyeLid Node</h1></center>
<h2>Eyelid:</h2>
Getting the the cornea bulge into a working eyelid setup in Maya.

Some of you prob have seen <a href="https://vimeo.com/66583205">Marco's approach for the "cartoony" eyelid</a> by now,
this approach doesn't really take into consideration the bulge of the cornea as the eye changes direction.

It works around the sphere based on aim constraints etc. And while this is a great for some setups,
I was posed with a different issue recently eg: include the bulge!

Why is the cornea bulge important?

If you close your eyelids and move your eye around it will deform the lid. Close up to
camera you're going to notice this subtle deformation missing.

Also, animators want to see this while they're working, which is kinda tricky if you're wanting to try to keep a speedy
rig and looking to avoid deformation approaches (sculpt deformers through curves / blendshapes etc).

This approach uses a node that pushes the eyelid joints out along an axis, by
using the centroid (of the sphere of the eye), away from the eyeball, with a falloff,
to simulate the effect of the cornea bulge .

I also wanted to see if I could get the hermite math implemented into node for nicer results along the lids.

<h2>What is a centroid?</h2>
Looking at wolfram 's example of a <a href="http://mathworld.wolfram.com/SphericalCap.html">spherical cap</a>

<img src="http://mathworld.wolfram.com/images/eps-gif/SphericalCap_1001.gif" alt="centroid">


<i>The geometric centroid occurs at a distance</i>:
{% highlight c++ %}
z^_=(3(2R-h)^2)/(4(3R-h))
{% endhighlight %}

It is the center of the flat plane created by slicing through the sphere by a given height.
Given;

- height h
- radius r
- push distance

we can work out a fall off radius for the push distance using the centroid.

- The > the height, the centroid has travelled further from the edge of the sphere = the bigger the fall off radius.
- The smaller the height, the centroid has travelled closer to the edge of the eyeball = the smaller the fall off radius.



{% highlight c++ %}
// Calc the bulge falloff and push vector for the cap
MFloatVector sphericalCapBulgeVector(float h, float radius, float bulgeDistance, MFloatVector affectedVector, MFloatVector sphereCenterZAxis){
	float radiusofCap = sqrt(h*(2.0f*radius-h));;
	float centrd = sqrt((radius * radius) - (radiusofCap * radiusofCap));

	MFloatVector distVector = affectedVector;
	distVector.normalize();
	distVector *= radius;

	MFloatVector sphereVector = sphereCenterZAxis;
	sphereVector.normalize();
	sphereVector *= radius;

	MFloatVector distanceBetweenVector = distVector - sphereVector;
	float distanceBetween = std::min(1.0f, distanceBetweenVector.length());

	float factorOf = std::max(0.0f, radiusofCap - distanceBetween);
	float pushResult = bulgeDistance * factorOf;

	MFloatVector affectedVectorResult(0.0f, 0.0f, -pushResult);
	return affectedVectorResult;
}
{% endhighlight %}


So here is a look at the node in action. Just the 2 runs of joints, one along the edge and the other up in the orbital area;
<center><img src="/assets/examples/eyelidTest01.gif" width="640" height="480" alt="eyelidMovement"></center>


To get this to play nicely I've setup some buffers / aim contraints with weightings, but nothing that was too complex
to deal with.


The first part of the video is me pulling just the lid control around with a bit of influence from that control going into the eyeball.


The 2nd part is clicking play, and running the animation that also animates the eyeball's lookat control to get the eye
to look around.


Some downsides to consider with this approach;


- the inner corners of the eyes are tricky as the math is based on a spherical shape, so I will most likely add
those joints in with a different setup.
- the extremes may result in cutting through the eyeball if there are not enough joints to hold the lids around
the sphere
- Getting the play of fat in the lid to work nicely is always somewhat tricky. Less joints = harder to resolve too.

Some upsides;

- nice hermite play across the lid
- get a nice control with clean translates to use to drive corrective blendshapes
- #Num of joints can be output from the node so there is only the need to set the number of controls you want
- The corner bulge pushes directly in the animation rig.

Will prob post more on this again later on when I get some time.

Things to work out:
- bias
- blinking from at any point top and bottom - tweakers are still very isolated in setup
