---
layout: default
title: "Eyelid - with bulge"
isPost: true
description: "Creating the eylid node in Maya"
usage: "N-A"
lastUpdated: "03-04-2018"
category: c++
---
<center><h1>Maya EyeLid Node</h1></center>
<h2>Eyelid:</h2>
Okay so the interesting part for an eyelid is essentially the cornea bulge.
<br>
Some of you prob have seen <a href="https://vimeo.com/66583205">Marco's approach for the "cartoony" eyelid</a> by now, this approach doesn't
really take into consideration the bulge.
<br>It works around the sphere based on aim constraints etc. And while this is a great for some setups,
I was posed with a different issue recently eg: include the bulge!
<br>
Why is the cornea bulge important?
<br>
Eyes well... have a cornea bulge! So if you close your eyelids and move your eye around it will deform the lid. Close up to ca
mera you're going to notice this aspect of deform missing.
<br>
Also, animators want to see this while they're working, which is kinda tricky if you're wanting to try to keep a speedy
rig and avoid deformation approaches (sculpt deformers etc).
<br>
<br>
So to that end, this approach tries to write a node that pushes the eyelid joints [as the eye moves around] as expected.
Thus, this approach is based on a push approach of the joints via the centroid [of the sphere of the eye].
<br>
<br>
This post covers looking at the implications of the such a setup / the pro's and con's (yes there are cons).
<br>

<h2>Why Investigate this?</h2>
<li> Well firstly to see if the hermite can be implimented into an eyelid set for nice curvatures to avoid some previous
complications experienced.
<li> To see if the deformation of the bulge can be included in the animation setup from the base rig! (It can as per a previous atttempt)
<li> To see if we can have this deformation/lid setup become an animator friendly rig! (Up for discussion)
<br>
<h2>What is a centroid?</h2>
Looking at wolframe's example of a <a href="http://mathworld.wolfram.com/SphericalCap.html">spherical cap</a>;
<img src="http://mathworld.wolfram.com/images/eps-gif/SphericalCap_1001.gif" alt="centroid">
<br>
<i>
The geometric centroid occurs at a distance:
<br>
z^_=(3(2R-h)^2)/(4(3R-h))
<br></i>
It is the center of the flat plane created by slicing through the sphere by a given height.
<br>
Given a height h, and a radius r, and the distance to push the buldge, we can take an affectedVector and push it based on the spheresZAxis.
{% highlight c++ %}
// Calc the bulge falloff and push vector for the cap
MFloatVector sphericalCapBulgeVector(float h, float radius, float bulgeDistance, MFloatVector affectedVector, MFloatVector sphereCenterZAxis){
	float radiusofCap = sqrt(h*(2.0f*radius-h));;
	float centrd = sqrt((radius * radius) - (radiusofCap * radiusofCap));

	MFloatVector distVector = affectedVector;
	distVector.normalize();
	distVector *= radius;

	MFloatVector sphereVector = sphereCenterZAxis;
	sphereVector.normalize();
	sphereVector *= radius;

	MFloatVector distanceBetweenVector = distVector - sphereVector;
	float distanceBetween = std::min(1.0f, distanceBetweenVector.length());

	float factorOf = std::max(0.0f, radiusofCap - distanceBetween);
	float pushResult = bulgeDistance * factorOf;

	MFloatVector affectedVectorResult(0.0f, 0.0f, -pushResult);
	return affectedVectorResult;
}
{% endhighlight %}
<image>

